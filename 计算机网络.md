# 1. TCP三次握手四次挥手

  

![](https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2590032753,2466318043&fm=173&app=49&f=JPEG?w=640&h=716&s=E7F239D247AFCCEA106594580300D072)
# 2. IP,UDP,TCP  header

### IP header

IP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。
优点：简单，高效。
无状态指：IP通信双方不同步传输数据的状态信息，所有的IP数据报的传输都是独立的。所以容易发生重复和乱序的情况并且IP层不予处理。
然后将这些乱序的交给上层传输层（TCP/UDP等）来处理，将其处理成有序的，正确的。再交给应用层。
不可靠指：IP协议不能保证IP数据报准确到达。所以它提供ICMP报文来辅助，一旦检测到IP数据报发送失败，通知上层协议。

IP头部信息：
头部长度：**通常20字节**，有选项时更长，总共**不超过60字节**。
**IP数据报长度：65535字节**

![这里写图片描述](https://img-blog.csdn.net/20170324223007286?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXRodW5kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

这里写图片描述
逐个分析：

- 4位版本号：IP协议（IPv4）版本号位4    
- 4位头部长度：标识头部有多少个4字节，即最大共15*4个字节       - 8位服务类型：包含一个4位优先权字段：最小延时，最大吞吐量，最高可靠性和最小费用。       
- 16位总长度：表示整个IP数据报的长度，最大表示65535，但**由于MTU限制，一般无法到达这个值** 。       
- 16位标识：唯一的标识数据报。系统采用加1的式边发送边赋值。       
- 3位标识（保留，DF禁止分片，MF更多分片）：所以这个标志是为分片存在，DF设置时禁止分片所以如果数据报太大则发送失败。MF设置时，如果产生分片，除了最后一个分片，其他此片置1。    
- 13位分片偏移：分片相对原始IP数据报开始处的偏移。       
- 8位生存时间（TTL）：数据报到达目的地之前允许经过的路由跳跳数。跳一下减1，得0丢弃。      
-  8位协议：用来区分上层协议（ICMP为1，TCP为6，UDP为17）。       
- 16位头部校验和：仅以CRC算法检验数据报头部在传输过程中是否损坏。    
- 32位源端口IP地址和目的端口地址很明白。       
- 选项（可变长）：记录路由，告诉途径得所有路由把IP填进来。    时间戳，告诉每个路由器都将数据报被转发的时间传进来。松散路由选择，指定一个路由器IP地址列表，必须按这个表发送，严格路由选择，数据报经过路由表。

说一下中间的分片部分：图中报文的第二层三个部分给IP的分片和重组提供了足够的信息：

   数据报标识：系统用+1法为每个数据报**唯一标识**此位，**如果数据13被分片，所有分的小片中此位都是13**。
   标志：共三位。第一位保留，第二位DF为禁止分片，第三位MF为更多分片，当产生分N片时，将1到N-1片此位置位。
   片偏移：表示当前数据报在完整数据报中的偏移，这里一个单位是8字节，比如片偏移为185，则代表该片在完整数据报的偏移是185*8=1480字节。


### TCP header

头部最少有4x5=**20个字节**
![](https://images2017.cnblogs.com/blog/822287/201712/822287-20171220194113475-1709447191.png)
![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1564755719907&di=6a1327d7bb067fac4f6b6dee89282c67&imgtype=0&src=http%3A%2F%2Fimg246.ph.126.net%2FdZY5yvDmey4HMir8zp9xkQ%3D%3D%2F1437211231086097203.png)
- 源端口号和目的端口号：再加上Ip首部的源IP地址和目的IP地址可以唯一确定一个TCP连接  
- 数据序号：表示在这个报文段中的第一个数据字节序号  
- 确认序号：仅当ACK标志为1时有效。确认号表示期望收到的下一个字节的序号（这个下面再详细分析）  
- **偏移：** 就是头部长度，有4位，跟IP头部一样，以4字节为单位。最大是60个字节  
- 保留位：6位，必须为0  
- 6个标志位：  
URG-紧急指针有效  
ACK-确认序号有效  
PSH-接收方应尽快将这个报文交给应用层  
RST-连接重置  
SYN-同步序号用来发起一个连接  
FIN-终止一个连接

- 窗口字段：16位，代表的是窗口的字节容量，也就是TCP的标准窗口最大为2^16 - 1 = 65535个字节（这个下面再详细分析）

- 校验和：源机器基于数据内容计算一个数值，收信息机要与源机器数值 结果完全一样，从而证明数据的有效性。**检验和覆盖了整个的TCP报文段**：这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证的。

- **紧急指针：** 是一个正偏移量，与序号字段中的值相加表示紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式  

- 选项与填充（必须为4字节整数倍，不够补0）：  
最常见的可选字段的最长报文大小MSS（Maximum Segment Size），每个连接方通常都在一个报文段中指明这个选项。它指明本端所能接收的最大长度的报文段。  
该选项如果不设置，默认为536（20+20+536=576字节的IP数据报）

# 3. 滑动窗口

**通告接收窗口（rwnd）**：预防应用程序发送的数据超过对方的缓冲区，接收方使用的流量控制。  
**拥塞窗口（cwnd）：** 预防应用程序发送的数据超过了网络所能承载的能力。发送方使用的流量控制。  
**发送窗口：** 就是指上面两者的较小值

由于TCP的全双工的，所以其实TCP双方各自都维护一个发送窗口和接收窗口。

假设是主机A发送给主机B  
A和B都会维护一个数据帧的序列，这个序列称为窗口。**发送方的窗口大小由接收方确定。目的在于控制发送速度。** 以免接收方的缓存不够大而导致溢出，同时流量控制也可以避免网络拥塞。  
这里其实是指A的发送窗口。

**发送方在发送过程中始终保持着一个发送窗口，只有落在发送窗口内的帧才允许被发送；同时接收方也维持着一个接收窗口，只有落在接收窗口内的帧才允许接收。**


![TCP滑动窗口详解 - Zark - Fighter Power](http://img2.ph.126.net/wAiySfw8790CM5ouSucQmA==/2598014035056341052.jpg)

  
假设A发送了很多段给B，序号是1-10.这些段会处于种状态：  
1）已发送，已确认  
2）已发送，未确认  
3）等待发送  
4）不允许发送

正常情况下，每个段都会由4状态->3状态->2状态->1状态。而窗口就是指处于状态2和状态3的总数。  
由2状态->1状态的时候，窗口就会往后滑动一下，表示最近那个4状态的段可以变成3状态了。  
如果接收方一直不确认，那么处于4状态的段将永远不会被发送。  
当窗口满了的时候，4状态的段将不会变成3状态。从而达到了控制发送速度的作用。


![](http://blog.chinaunix.net/attachment/201402/17/26275986_1392627535jeG5.png)
**拥塞控制**  
网络中的链路容量和交换结点中的缓存和处理机都有着工作的极限，当网络的需求超过它们的工作极限时，就出现了拥塞。拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。常用的方法就是：  
1. 慢开始、拥塞控制  
2. 快重传、快恢复  
一切的基础还是慢开始，这种方法的思路是这样的：  
-1. 发送方维持一个叫做“**拥塞窗口**”的变量，该变量**和接收端口共同决定了发送者的发送窗口**；  
-2. 当主机开始发送数据时，避免一下子将大量字节注入到网络，造成或者增加拥塞，选择发送一个1字节的试探报文；  
-3. 当收到第一个字节的数据的确认后，就发送2个字节的报文；  
-4. 若再次收到2个字节的确认，则发送4个字节，依次递增2的指数级；  
-5. 最后会达到一个提前预设的“慢开始门限”，比如24，即一次发送了24个分组，此时遵循下面的条件判定：  
*1. cwnd < ssthresh， 继续使用慢开始算法；  
*2. cwnd > ssthresh，停止使用慢开始算法，改用拥塞避免算法；  
*3. cwnd = ssthresh，既可以使用慢开始算法，也可以使用拥塞避免算法；  
-6. 所谓拥塞避免算法就是：每经过一个往返时间RTT就把发送方的拥塞窗口+1，即让拥塞窗口缓慢地增大，按照线性规律增长；  
-7. 当出现网络拥塞，比如丢包时，将慢开始门限设为原先的一半，然后将cwnd设为1，执行慢开始算法（较低的起点，指数级增长）；  
![](http://blog.chinaunix.net/attachment/201402/17/26275986_1392629245IG6b.png)  
上述方法的目的是在拥塞发生时循序减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够的时间把队列中积压的分组处理完毕。慢开始和拥塞控制算法常常作为一个整体使用，而快重传和快恢复则是为了**减少因为拥塞导致的数据包丢失带来的重传时间，从而避免传递无用的数据到网络**。快重传的机制是：  
-1. 接收方建立这样的机制，如果一个包丢失，则对后续的包继续发送针对该包的重传请求；  
-2. 一旦发送方接收到三个一样的确认，就知道该包之后出现了错误，立刻重传该包；  
-3. 此时发送方开始执行“快恢复”算法：  
*1. 慢开始门限减半；  
*2. cwnd设为慢开始门限减半后的数值；  
*3. 执行拥塞避免算法（高起点，线性增长）；  
![](http://blog.chinaunix.net/attachment/201402/17/26275986_1392629231ue0O.png)
# 4. 长连接与短连接

答：（1）就是TCP长连接和TCP短连接：

①TCP长连接：TCP长连接指建立连接后保持连接而不断开。若一段时间内没有数据传输，服务器会发送心跳包给客户端，判断客户端是否还在线，叫做TCP长连接中的keep alive。一般步骤：连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接；

②TCP短连接：指连接建立并传输数据完成后，就断开连接。一般步骤：连接→数据传输→关闭连接；

③使用场景：长连接适合单对单通信且连接数不太多的情况；短连接适合连接数多且经常更换连接对象的；

（2）HTTP是什么连接：

①在HTTP/1.0中，默认使用的是短连接。但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：

Connection:keep-alive

注意：此处的keep-alive和上述TCP长连接原理介绍中的keep alive不是一个意思：此处表示告知服务器本http请求是长连接模式，而TCP长连接中的keep alive表示对客户端的保活检测。

②http长连接并不是一直保持连接

http的长连接也不会是永久保持连接，它有一个保持时间如20s（从上一次数据传输完成开始计时），可以在不同的服务器软件（如Apache）中设定这个时间，若超过该时间限制仍然无数据通信传输，服务器就主动关闭该连接。注：实现长连接要客户端和服务端都支持长连接。

③http连接实质：http的长连接/短连接实质上就是TCP的长/短连接。

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEyOTMyODk4MTUsMTAxMzcyNDA3OCwtMT
AxOTI2MzMwOCw3NDgzMjc3NzIsMTYxODAxOTk4Ml19
-->